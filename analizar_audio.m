function [] = analizar_audio(nombre_archivo)  pkg load signal;  clc; clear all; close all;##---------------------------------------------------------------------------##  CARGA DE SENIALES CON COMANDOS DISPONIBLES EN EL SISTEMA##  (para comparar luego con la senial de entrada)##---------------------------------------------------------------------------##  [y_adelante, fm_adelante] = audioread("dataset-ajustes/adelante.wav");##  [y_atras, fm_atras] = audioread("dataset-ajustes/atras.wav");##  [y_derecha, fm_derecha] = audioread("dataset-ajustes/derecha.wav");##  [y_izquierda, fm_izquierda] = audioread("dataset-ajustes/izquierda.wav");##  [y_parar, fm_parar] = audioread("dataset-ajustes/parar.wav");##---------------------------------------------------------------------------##  LECTURA DE LA SENIAL DE VOZ DE ENTRADA##---------------------------------------------------------------------------  % y: es la senial recibida, fm: es la frecuencia de muestreo  % [y, fm] = audioread(nombre_archivo);  [y, fm] = audioread("dataset-ajustes/adelante_1.wav");  [y2, fm2] = audioread("dataset-ajustes/adelante_2.wav");##  [y, fm] = wavread(archivo);   otra opcion que se puede probar##  yo = y; % y original para graficar si nos sirve##  fm##  sound(y)  % para escuchar el audio##  sound(y2)  figure(1)  plot(y)  title("Senal 1")  figure(2)  plot(y2)  title("Senal 2")    % Si la senial recibida se encuentra como vector columna, se tranforma a vector fila  if(length(y(1,:)) < length(y(:,1)))    y = y';  endif##  % Para probar que da la correlacion cruzada##  correlacion_cruzada = xcorr(y, y2);##  max_correlacion_cruzada = max(correlacion_cruzada)####  figure(3)##  plot(correlacion_cruzada)##  title("Correlacion cruzada")##---------------------------------------------------------------------------  ## A continuación, primero se realiza un acondicionamiento de la señal, el cual incluye:  ## -Remocion de la media.  ## -Filtrado para eliminacion de ruido  ## -Filtrado pre-enfasis,  ## -Ventaneo.  ## -Segmentado de tramas sonoras.    ## Luego de eso se extraen los coeficientes cepstrales es escala de Mel,  ## para posteriormente comparar con los comandos de voz disponibles en el sistema  ## utilizando la tecnica DTW y verificar cual es el comando de voz mas parecido  ## a la senal de entrada, y si se supera cierto umbral de similitud, se indica  ## cual es el comando a ejecutar.##---------------------------------------------------------------------------##---------------------------------------------------------------------------##  REMOCION DE LA MEDIA (QUITAR COMPONENTE CONTINUA)##---------------------------------------------------------------------------  ## La componente continua es una desviacion general de la senial, positiva o  ## negativa debido principalmente a microfonos de mala calidad o a campos magneticos  ## presentes. Esto afecta de forma critica en etapas posteriores del procesado.  ## La componente continua se elimina restando la media de la senial a cada  ## una de las muestras.  y = y - mean(y);##---------------------------------------------------------------------------##  FILTRADO PARA ELIMINACION DE RUIDO##---------------------------------------------------------------------------  ## Es posible que en la senial se hayan introducido componentes de baja  ## frecuencia procedentes de distintas fuentes. Estas componentes no son de  ## interes para el estudio de la senal de voz y por ello es mejor eliminarlas. La  ## frecuencia de corte se ha establecido en 75 Hz que es la minima a la que se  ## encuentra la frecuencia fundamental (pitch) para la voz masculina  f_min = 75;  f_max = 3000;   % filtrando hasta menos de 3000 la voz en nuestro caso se distorsiona.                  % si la senal tiene fm = 8000 Hz, la f maxima es de 4000, asi                  % que estaria eliminando la parte de 0 a 74 y 3001 a 4000 Hz  senal_filtrada = filtrar_senal(y, fm, f_min, f_max);  sound(senal_filtrada);  senal_filtrada2 = filtrar_senal(y2, fm2, f_min, f_max);  sound(senal_filtrada2);  ##  [dist, an, idx_ij] = DTW(y, y2');####  [dist, an, idx_ij] = DTW(y, y);##  % Periodo de muestreo##  Tm = 1/fm;##  % Vector de tiempos##  t = 0 : Tm : (length(y)*Tm)-Tm;####  % Con la funcion TDF calcula la transformada de Fourier y acomoda el rango de frecuencias.##  [Y_sin_filtro, f] = TDF(y, Tm);####  figure(4)##  plot(Y_sin_filtro)####  % Filtro pasa-banda##  Filtro = (abs(f) >= 75 & abs(f) <= 400);  % unos en esa banda de 75 a 400 Hz y ceros en el resto##  Y = Y_sin_filtro .* Filtro;####  figure(5)##  plot(Y)##---------------------------------------------------------------------------##  FILTRADO PRE-ENFASIS##---------------------------------------------------------------------------  ## Filtrado de primer orden donde se realza o enfatizan las altas frecuencias  a = 0.97;  for n = 1:length(y)    if(n-1 > 0)      y(n) = y(n) - a*y(n-1);    endif  endfor
##---------------------------------------------------------------------------##  VENTANEO##---------------------------------------------------------------------------  ## En intervalos cortos de tiempo la se?al se estabiliza y se aproxima a una se?al estacionaria,  ## entonces es necesario dividir utilizando ventanas, donde la mas utilizada es la ventana de Hamming.  ## Cuanto mas rapido se pronuncie, sera necesario un menor tama?o de ventana, pero suelen utilizarse  ## entre 10 y 30 ms.  ## Otro tema es tratar de superponer las ventanas (overlap), a mayor velocidad, mayor tiene que ser el overlap.  tvent = 0.03;   % ancho de la ventana de an?lisis en segundos (30 ms)  %overlap = 0.4;    % 40%, cantidad de solapamiento entre ventanas de an?lisis, 0 solapamiento total, 1 no hay solapamiento  tstep = 0.01;  % avance de la ventana (10 ms)  % Transformo esos tiempos en muestras  nvent = tvent * fm;  nstep = tstep * fm;  # Comento no mas, existe funcion hamming(N) donde N es la cantidad de elementos que  # deseas en esta ventana. Hay que prestar atencion porque la funcion devuelve  # un vector vertical. Por lo que veo, estas haciendo una ventana con un tamano  # de la senal original.##  % Ventana##  w = vhamming(t);##  y_ventaneada = w*y;   % VER COMO SERIA (ver en ej. 1 guia 8)  # En el ejercicio propuso iniciar en la mitad de la ventana, osea ini = nvent/2  # Luego termina una ventana antes de la final.  # Las explicaciones se encuentra en el video 2 de Guia 8 minuto 48:50.  ini = nvent/2;  nframes = floor((length(y) - nvent*0.5 - nvent - nstep)/nstep);  # Ventanear las senales  for i = 1: nframes    # Ventanear una parte de la senal. Por su puesto que falta algo    ...y(ini: ini + nvent - 1) .* hamming(nvent)';  endfor##---------------------------------------------------------------------------##  SEGMENTADO DE TRAMAS (VENTANAS) SONORAS##---------------------------------------------------------------------------  ## Las tramas que contienen la informacion mas relevante para la caracterizacion son   ## las llamadas sonoras. Por ese motivo es necesario establecer unos criterios que   ## permitan aislar este tipo de tramas y desechar las pertenecientes a silencios o a sonidos sordos.  ## Para este fin existen tres metodos, el calculo de la energia, la tasa de cruces   ## por cero (ZCR), y el calculo del pitch. En este caso, utilizaremos el calculo de la energia.  ## Es necesario definir un umbral de energia para discernir si un determinado  ## coeficiente de energia pertenece o no a una trama sonora. Para dar  ## estabilidad al cadalculo del parametro, ademas de eliminar la componente  ## continua de la señal, también se puede normalizar entre 1 y -1.    ## Tenemos la funcion "energia" que podriamos ir aplicando a cada ventana,   ## y si supera un umbral la consideramos como sonora y sino como sorda y la descatamos  ## o la cambiamos por todos ceros para que la senal siga con el mismo tamanio.   ##---------------------------------------------------------------------------##  EXTRACCION DE CARACTERISTICAS (Coeficientes cepstrales en escala de Mel)##---------------------------------------------------------------------------  ## Al final de la pag. 13 del word de anotaciones de teoria y en otros archivos se habla de estos MFCC,  ## y se explica los pasos para calcularlos (pre-enfasis, ventaneo, Fourier, banco de filtros,  ## logaritmo, transformada coseno, liftrado) y se muestra una imagen.  ## Se calculan en cada ventana.  ## Ver si debemos usar esos mismos pasos.  ##  cr = real(ifft(log(abs(fft(y))))); % cepstrum##---------------------------------------------------------------------------##  CORRELACION CRUZADA##---------------------------------------------------------------------------  ##  QUIZAS NO SON NECESARIOS, LO VEMOS DESPUES.    ## r = xcorr(x,y) devuelve la correlacion cruzada de dos secuencias de tiempo diferenciado.  ## La correlacion cruzada mide la similitud entre un vector "x" y las copias desplazadas (desfasadas)  ## de un vector "y" como funcion del desfase. Si "x" e "y" tienen longitudes diferentes,  ## la funcion agrega ceros al final del vector mas corto para que tenga la misma longitud que el otro.  ## Se deberia hacer la correlacion cruzada entre la senial de entrada y las cinco  ## seniales de comandos disponibles en el sistema.  ## Tambien debemos usar la tecnica dynamic time warping (DWT) para hacer un ajuste entre las seniales  ## que nos permita realizar la comparaciin, porque pueden ser de distinta duracion y entonces no usan  ## la misma cantidad de ventanas.##---------------------------------------------------------------------------##  IDENTIFICACION DE COMANDO##---------------------------------------------------------------------------  ## La senial con mayor correlacion sera la de mayor similitud con la senial de entrada,  ## determinando asi cual es el comando que el usuario desea ejecutar  ## Se busca el comando con mayor similitud a la senal de entrada y si se supera   ## cierto umbral de similitud, se indica como comando valido.     ##---------------------------------------------------------------------------##  RESULTADO##---------------------------------------------------------------------------  ## Mostrar si la senial de entrada fue un comando valido o noendfunction